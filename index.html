<script>
/*
  Client loader + search for GitHub Pages setup (Option A)
  - Tries /data/products.json then ./data/products.json
  - Enables search input and renders results
  - Debounced input handling
  - Fallback to any sampleProducts defined in the page (if fetch fails)
*/

(async function() {
  const STATUS_EL = document.getElementById('status');
  const SEARCH_EL = document.getElementById('searchBox');
  const RESULTS_EL = document.getElementById('results');
  const LOAD_BTN = document.getElementById('loadBtn');

  // If you already declared sampleProducts earlier in the page, we'll use it as a fallback.
  const fallbackSamples = window.sampleProducts || [];

  let liquorData = [];
  let isLoaded = false;

  function setStatus(text, type) {
    if (!STATUS_EL) return;
    STATUS_EL.style.display = 'block';
    STATUS_EL.className = 'status' + (type ? ' ' + type : '');
    STATUS_EL.innerHTML = text;
  }

  function clearStatus() {
    if (!STATUS_EL) return;
    STATUS_EL.style.display = 'none';
    STATUS_EL.innerHTML = '';
  }

  // Try two common relative paths so the client works both at repo root and project page path
  async function tryFetchPaths() {
    const paths = ['/data/products.json', './data/products.json', 'data/products.json'];
    for (const p of paths) {
      try {
        setStatus('Loading product index (' + p + ') ...');
        const resp = await fetch(p, { cache: 'no-store' });
        if (!resp.ok) {
          console.warn('Not found at', p, resp.status);
          continue;
        }
        const json = await resp.json();
        return json;
      } catch (err) {
        console.warn('Fetch failed for', p, err);
      }
    }
    return null;
  }

  async function loadProducts() {
    const arr = await tryFetchPaths();
    if (arr && Array.isArray(arr) && arr.length) {
      liquorData = arr;
      isLoaded = true;
      setStatus('✅ Loaded ' + arr.length + ' products from products.json', 'success');
      return;
    }

    // fallback to sample products if provided in page
    if (fallbackSamples && fallbackSamples.length) {
      liquorData = fallbackSamples;
      isLoaded = true;
      setStatus('⚠️ Could not load remote products.json — using sample data', 'error');
      return;
    }

    // final fallback: nothing available
    liquorData = [];
    isLoaded = false;
    setStatus('❌ Could not load products.json and no sample data available', 'error');
  }

  function numericFrom(x){
    if (x == null) return null;
    if (typeof x === 'number') return x;
    const n = (''+x).replace(/[^0-9.\-]/g,'').trim();
    return n ? parseFloat(n) : null;
  }

  function formatPrice(p){
    const n = numericFrom(p);
    if (n == null || isNaN(n)) return '';
    return '$' + n.toFixed(2);
  }

  // Basic search: code, upc1, upc2, brandName, vendorName, liquorType
  function searchProducts(q) {
    if (!isLoaded) return [];
    if (!q || q.trim().length < 1) return [];
    q = q.toLowerCase();
    const results = [];
    for (const it of liquorData) {
      if (!it) continue;
      if ((it.liquorCode && it.liquorCode.toLowerCase().includes(q)) ||
          (it.upc1 && it.upc1.toLowerCase().includes(q)) ||
          (it.upc2 && it.upc2.toLowerCase().includes(q)) ||
          (it.brandName && it.brandName.toLowerCase().includes(q)) ||
          (it.vendorName && it.vendorName.toLowerCase().includes(q)) ||
          (it.liquorType && it.liquorType.toLowerCase().includes(q))) {
        results.push(it);
        if (results.length >= 200) break; // limit for performance
      }
    }
    return results;
  }

  function renderResults(list) {
    if (!RESULTS_EL) return;
    if (!list || list.length === 0) {
      RESULTS_EL.innerHTML = '<div class="no-results"><h3>No results found</h3><p>Try a different search term</p></div>';
      return;
    }

    const html = list.map(p => {
      const code = p.liquorCode || '';
      const name = p.brandName || p.name || '(no name)';
      const type = p.liquorType || p.type || '';
      const vendor = p.vendorName || p.vendor || '';
      const size = p.bottleSize || p.size || '';
      const proof = p.proof || '';
      const onP = formatPrice(p.onPremPriceN ?? p.onPremPrice);
      const offP = formatPrice(p.offPremPriceN ?? p.offPremPrice);
      const shelf = formatPrice(p.shelfPriceN ?? p.shelfPrice);
      const upc = p.upc1 || p.upc || '';
      return `
        <div class="product">
          <div class="product-name">${escapeHtml(name)}</div>
          <div class="product-details">
            <div class="detail-row"><strong>Type:</strong> ${escapeHtml(type)}</div>
            <div class="detail-row"><strong>Size:</strong> ${escapeHtml(size)} ${proof ? '| <strong>Proof:</strong> ' + escapeHtml(proof) : ''}</div>
            <div class="detail-row"><strong>Vendor:</strong> ${escapeHtml(vendor)}</div>
          </div>
          <div class="prices">
            <div class="price-box"><div class="price-label">On-Premise</div><div class="price-value">${onP}</div></div>
            <div class="price-box"><div class="price-label">Off-Premise</div><div class="price-value">${offP}</div></div>
            <div class="price-box"><div class="price-label">Shelf Price</div><div class="price-value">${shelf}</div></div>
          </div>
          <div class="codes">Code: ${escapeHtml(code)} ${upc ? '| UPC: ' + escapeHtml(upc) : ''}</div>
        </div>
      `;
    }).join('\n');

    RESULTS_EL.innerHTML = html;
  }

  // small helper to prevent HTML injection
  function escapeHtml(s) {
    if (s == null) return '';
    return String(s)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  // debounce helper
  function debounce(fn, wait) {
    let t = null;
    return function(...args) {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), wait);
    };
  }

  // wire UI
  if (LOAD_BTN) {
    LOAD_BTN.addEventListener('click', async function() {
      // If not loaded yet, try loading the official JSON, otherwise refresh
      setStatus('Attempting to load products.json from site...', '');
      await loadProducts();
      if (isLoaded) {
        if (SEARCH_EL) SEARCH_EL.disabled = false;
        LOAD_BTN.textContent = 'Refresh Live Data';
      }
    });
  }

  if (SEARCH_EL) {
    SEARCH_EL.disabled = true; // enable after load
    const onInput = debounce(function(e) {
      const q = (e.target.value || '').trim();
      if (q.length < 2) {
        RESULTS_EL.innerHTML = '';
        return;
      }
      const res = searchProducts(q);
      renderResults(res.slice(0, 100));
    }, 150);
    SEARCH_EL.addEventListener('input', onInput);
  }

  // initial load at startup
  try {
    await loadProducts();
    if (isLoaded) {
      if (SEARCH_EL) {
        SEARCH_EL.disabled = false;
        SEARCH_EL.focus();
      }
      if (LOAD_BTN) LOAD_BTN.textContent = 'Refresh Live Data';
    } else {
      // allow searching fallback sample if present
      if (fallbackSamples && fallbackSamples.length) {
        if (SEARCH_EL) SEARCH_EL.disabled = false;
        setStatus('Using sample data. Click "Try Live Data" to attempt loading the official file.', 'error');
      }
    }
  } catch (err) {
    console.error('Init error', err);
    setStatus('Unexpected error while loading data', 'error');
  }

})();
</script>
